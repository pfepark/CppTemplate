### 완벽한 전달 (perfect forwarding)

전달된 인자의 기본 속성을 전달하는 일반 코드를 작성하는 중이라고 해보자.

- 수정할 수 있는 객체는 여전히 수정할 수 있는 상태로 전달돼야 한다.
- 상수 객체는 읽기 전용 객체로 전달돼야 한다.
- 이동 가능한 객체(곧 사라질 것이므로 훔칠 수 있는 객체)는 이동 가능한 객체로 전달돼야 한다.

이러한 기능을 템플릿 없이 구현 하려면 세 가지 상황 모두를 따로 프로그래밍 해야 한다.

이동 가능한 객체(rvalue참조자)를 위한 코드가 그 외의 코드와 다르다는 점에 주의하자. 여기서는 언어 볍칙에 따라 이동 의미 체계가 동작하지 않기 때문에 std::move()가 사용된다. 세 번째 f()에 있는 val이 rvalue 참조자로 선언됐기는 하지만 이 변수가 표현식으로 쓰일 때의 값 카테고리는 비상수 lvalue이며 첫 번째 f()의 val처럼 행동한다. move()가 없다면 g(x&&)대신 비상수 lvalue를 위한 g(x&)가 호출될 것이다.

이 세 가지 경우를 일반 코드로 묶으려 하면 다음과 같은 문제가 발생한다.

```cpp
template<typename T>
void f(T val) {
  g(T);
}
```



이 코드는 처음 두 경우에는 잘 동작하지만 이동 가능한 객체를 전달받은 세 번째 경우에 대해서는 잘 동작하지 않는다.

C++11은 그래서 파라미터를 완벽히 전달하는 특별한 법칙을 만들었다. 완벽히 전달을 하고 싶다면 다음 코드 패턴을 관용구처럼 알아놓자.

```cpp
template<typename T>
void f(T&& val) {
  g(std::forward<T>(val)); //g()로 val을 완벽히 전달 (perfect forwarding)
}
```

std::move()는 템플릿 파라미터를 갖지 않고 전달받은 인자에 대해 이동 의미 체계를 촉발시키는 데 반해 std::forward<>()는 전달된 템플릿 인자에 따라 잠재적인 이동 의미 체계를 전달시킨다는 점을 기억하자.

- 특정 형식 X에 대한 X&&는 파라미터를 rvalue 참조자로 선언한다. 이동 가능한 객체에만 사용될 수 있다. (임시 객체와 같은 prvalue와 std::move()로 전달된 객체와 같은 xvalue) 항상 수정할 수 있으며 그 값을 훔칠 수 있다.
- 템플릿 파라미터 T에 대한 T&&는 전달 참조자 (forward reference, 혹은 universal reference)를 선언한다. 수정할 수 있는, 수정할 수 없는 혹은 이동 가능한 객체를 나타낼 수 있다. 함수 선언 내에서 파라미터는 수정할 수 있을 수도 있고 없을 수도 있으며 그 안의 값을 훔칠 수 있는 값을 나타낼 수도 있다. T가 템플릿 파라미터의 진짜 이름이어야 한다는 점에 유념하자. 템플릿 파라미터에 의존하는 것만으로는 충분하지 않다. 템플릿 파라미터 T가 있을 때 typename T ::iterator&&와 같은 선언은 그냥 rvalue 참조자일뿐 전달 참조자가 아니다.



```cpp
class X {
...
};

void g(X&) {
 std::cout << "g() for variable\n";
}

void g(X const &) {
 std::cout << "g() for constant\n";
}

void g(X&&) {
 std::cout << "g() for movable object\n";
}

// f()가 인자인 val을 g()로 완벽히 전달하게 해보자
template<typename T>
void f(T&& val) {
 g(std::forward<T>(val)); // 전달받은 어떠한 인자 val이라도 올바른 g()를 호출한다.
}

int main()
{
 X v;
 X cosnt c;
 f(v); 변수에 대해 f() 호출 시 f(X&)가 사용됨 => g(X&) 호출됨
 f(c); 상수에 대해 f() 호출 시 f(X const &)가 사용됨 => g(X const &) 호출됨
 f(X()); 임시 값에 대해 f() 호출 시 f(X&&)가 사용됨 => g(X&&) 호출됨
 f(std::move(v)); 이동이 허용된 변수에 대해 f() 호출 시 f(X&&)가 사용됨 => g(X&&) 호출됨
}

```

